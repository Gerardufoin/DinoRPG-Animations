// @ts-check
// https://github.com/motion-twin/WebGamesArchives/blob/main/DinoRPG/gfx/fight/src/fx/gr/Lava.hx

import { Layers } from '../../../DepthManager.js';
import { FighterProperty } from '../../../Enums.js';
import { Fighter } from '../../../Fighter.js';
import { Scene } from '../../../Scene.js';
import { Timer } from '../../../Timer.js';
import { GroupEffect } from '../GroupEffect.js';
import { SCENE_WIDTH } from '../../../IScene.js';
import { WaterCanon } from '../../../parts/skills/watercanon/WaterCanon.js';
import { Puddles } from '../../../parts/skills/watercanon/Puddles.js';
import { PixiHelper } from '../../../../display/PixiHelper.js';

/**
 * The caster blast its target with a water pillar.
 */
export class GrWaterCanon extends GroupEffect {
	/**
	 * The water canons.
	 * @type {WaterCanon[]}
	 */
	_canons = [];
	/**
	 * The puddles generated by the skill.
	 * @type {Puddles}
	 */
	_puddles;

	/**
	 * The caster runs to its target and blast it with a water canon.
	 * @param {Scene} scene The Scene where the effect takes place.
	 * @param {() => void} endCall The callback at the end of the State.
	 * @param {Fighter} caster The Fighter casting the skill.
	 * @param {{fighter: Fighter, life?: number}[]} targets The targets of the skill.
	 */
	constructor(scene, endCall, caster, targets) {
		super(scene, endCall, caster, targets);
		if (this._targets.length == 0) {
			this.end();
			return;
		}
		this._caster.playAnim('cast');
		this.goto(
			SCENE_WIDTH * 0.5 - 20,
			this._targets.reduce((acc, obj) => acc + obj.fighter.position.y, 0) / this._targets.length + 0.2
		);
	}

	/**
	 * Update the skill effets.
	 * @param {Timer} timer The Fight's Timer, containing the elapsed time.
	 */
	update(timer) {
		super.update(timer);

		switch (this._step) {
			case 0:
				this._caster.updateMove(this._coef);
				if (this._coef === 1) {
					this._caster.setSens(true);
					this.nextStep();
					this._caster.playAnim('release');
					this._coefSpeed = 0.03;

					for (const t of this._targets) {
						const canon = new WaterCanon(this._scene, this._caster, t.fighter);
						this._canons.push(canon);
						this._scene.dm.addSprite(canon, Layers.Scene.FIGHTERS);
					}

					this._puddles = new Puddles();
					this._scene.dm.addSprite(this._puddles, Layers.Scene.SHADE);
				}
				break;
			case 1:
				for (const t of this._targets) {
					if (t.life !== null) {
						if (!t.fighter.haveProp(FighterProperty.Static)) {
							t.fighter._x += Math.random() * 3 * -t.fighter.intSide * timer.tmod;
						}
						if (PixiHelper.tmodRandom(1 / 3, timer.tmod)) {
							this._puddles.addPuddle(t.fighter.position.x, this._scene.getY(t.fighter.position.y));
						}
					}
				}

				if (this._coef == 1) {
					this._canons.map((c) => c.close());
					this.nextStep();
					this.damageAll();
					this._coefSpeed = 0.1;
				}
				break;
			case 2:
				if (this._coef == 1) {
					this._coefSpeed = this._caster.initReturn();
					this.nextStep();
				}
				break;
			case 3:
				this._caster.updateMove(this._coef);
				if (this._coef == 1) {
					this._caster.backToDefault();
					this._puddles.discard();
					this.end();
				}
		}
	}
}
