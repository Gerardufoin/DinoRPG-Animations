// @ts-check
// https://github.com/motion-twin/WebGamesArchives/blob/main/DinoRPG/gfx/fight/src/fx/Focus.hx
// https://github.com/motion-twin/WebGamesArchives/blob/main/DinoRPG/gfx/fight/src/fx/Generate.hx

import { GlowFilter } from '@pixi/filter-glow';
import { Fighter } from '../../../Fighter.js';
import { Scene } from '../../../Scene.js';
import { State } from '../../../State.js';
import { Focus } from '../../../parts/skills/Focus.js';
import { Timer } from '../../../Timer.js';
import { PixiHelper } from '../../../../display/PixiHelper.js';
import { Layers } from '../../../DepthManager.js';
import { SkillRay } from '../SkillRay.js';
import { RayGenerate } from '../../../parts/skills/RayGenerate.js';

/**
 * The given Fighter starts focusing its power.
 */
export class FxFocus extends State {
	/**
	 * The Glow Filter of the ball and rays.
	 * Static to prevent WebGL from creating a new shader each time.
	 * @type {GlowFilter}
	 */
	static GlowFilter = new GlowFilter({
		distance: 10,
		outerStrength: 2,
		quality: 0.5
	});

	/**
	 * The Fighter casting the aura.
	 * @type {Fighter}
	 */
	_caster;
	/**
	 * The focus animation.
	 * @type {Focus}
	 */
	_ball;
	/**
	 * The size of the rays generated by the skill.
	 * @type {number}
	 */
	_radius;
	/**
	 * True if the rays are moving inward, false otherwise.
	 */
	_rayInward;

	/**
	 * The given Fighter focuses its power and creates an aura of the given color.
	 * @param {Scene} scene The Scene where the effect takes place.
	 * @param {() => void} endCall The callback at the end of the State.
	 * @param {Fighter} fighter The target of the attachement.
	 * @param {boolean} inward The direction of the ray. True for the ray to go inward, false otherwise.
	 * @param {number} color The color of the aura.
	 * @param {number} power The scale of the ball.
	 * @param {number} radius The scale of the rays.
	 */
	constructor(scene, endCall, fighter, inward, color, power = 1, radius = 1) {
		super(scene, endCall);
		this._caster = fighter;
		this._coefSpeed = inward ? 0.025 : 0.03;
		this._radius = radius;
		this._rayInward = inward;

		this._caster.playAnim('cast');
		this._ball = new Focus(0, -this._caster.height * 0.5, power);
		this._caster.dm.addSprite(this._ball, Layers.Fighter.FRONT);
		FxFocus.GlowFilter.color = color;
		this._ball.addFilters(FxFocus.GlowFilter);
	}

	/**
	 * Update the ball and rays animations.
	 * @param {Timer} timer The Fight's Timer, containing the elapsed time.
	 */
	update(timer) {
		super.update(timer);

		if (this._coef < 0.9 && PixiHelper.tmodRandom(0.5, timer.tmod)) {
			for (let i = 0; i < 3; ++i) {
				let ray;
				if (this._rayInward) {
					ray = new SkillRay(this._scene, -this._caster.height * 0.5);
				} else {
					ray = new RayGenerate(this._scene, -this._caster.height * 0.5, this._radius);
				}
				ray.addFilters(FxFocus.GlowFilter);
				this._caster.dm.addSprite(ray, Math.random() <= 0.66 ? Layers.Fighter.BACK : Layers.Fighter.FRONT);
			}
			this._ball.setSize(this._coef);
		}

		if (this._coef === 1) {
			this._ball.burst();
			this.end();
		}
	}
}
